/**
 * üß™ Script de test Frontend Sessions - Single-Active-Session
 * 
 * Ce script simule le comportement frontend pour tester :
 * 1. La gestion des erreurs SESSION_REVOKED
 * 2. Les √©v√©nements personnalis√©s
 * 3. La logique de d√©connexion automatique
 * 
 * Usage: node test-frontend-sessions.js
 */

const admin = require('firebase-admin');
const axios = require('axios');

// Configuration Firebase (utiliser les variables d'environnement)
const { admin: firebaseAdmin } = require('./firebase-config');

// Configuration de l'API
const API_URL = process.env.API_URL || 'http://localhost:3006/api';

// Variables de test
let testUser = null;
let testSession = null;
let secondSession = null;

/**
 * üß™ Test 1: Cr√©ation d'un utilisateur de test
 */
async function createTestUser() {
    console.log('\nüß™ Test 1: Cr√©ation d\'un utilisateur de test...');
    
    try {
        // Cr√©er un utilisateur de test dans Firestore
        const userData = {
            email: `test-${Date.now()}@wealthsense.com`,
            firstName: 'Test',
            lastName: 'User',
            role: 'user',
            sessionPolicy: 'single',
            createdAt: Date.now()
        };
        
        const userRef = firebaseAdmin.firestore().collection('users').doc();
        await userRef.set(userData);
        
        testUser = {
            uid: userRef.id,
            ...userData
        };
        
        console.log('‚úÖ Utilisateur de test cr√©√©:', {
            uid: testUser.uid,
            email: testUser.email,
            role: testUser.role
        });
        
        return testUser;
    } catch (error) {
        console.error('‚ùå Erreur cr√©ation utilisateur:', error);
        throw error;
    }
}

/**
 * üß™ Test 2: Cr√©ation de la premi√®re session
 */
async function createFirstSession() {
    console.log('\nüß™ Test 2: Cr√©ation de la premi√®re session...');
    
    try {
        // Simuler une requ√™te de login
        const loginData = {
            email: testUser.email,
            password: 'testpassword123'
        };
        
        // Note: Ceci est une simulation car nous n'avons pas de vrai syst√®me d'auth
        // En r√©alit√©, le backend cr√©erait la session via sessionManager.createSession()
        
        // Cr√©er manuellement une session de test
        const sessionData = {
            uid: testUser.uid,
            deviceId: `device_${Date.now()}_1`,
            deviceLabel: 'Chrome sur Windows',
            email: testUser.email,
            status: 'active',
            reason: null,
            replacedBy: null,
            createdAt: Date.now(),
            revokedAt: null,
            lastUsed: Date.now(),
            tokenFamily: `device_${Date.now()}_1`
        };
        
        const sessionRef = firebaseAdmin.firestore().collection('sessions').doc();
        await sessionRef.set(sessionData);
        
        testSession = {
            jti: sessionRef.id,
            ...sessionData
        };
        
        console.log('‚úÖ Premi√®re session cr√©√©e:', {
            jti: testSession.jti,
            deviceLabel: testSession.deviceLabel,
            status: testSession.status
        });
        
        return testSession;
    } catch (error) {
        console.error('‚ùå Erreur cr√©ation premi√®re session:', error);
        throw error;
    }
}

/**
 * üß™ Test 3: Cr√©ation de la deuxi√®me session (devrait r√©voquer la premi√®re)
 */
async function createSecondSession() {
    console.log('\nüß™ Test 3: Cr√©ation de la deuxi√®me session (devrait r√©voquer la premi√®re)...');
    
    try {
        // Simuler une nouvelle connexion depuis un autre appareil
        const sessionData = {
            uid: testUser.uid,
            deviceId: `device_${Date.now()}_2`,
            deviceLabel: 'Safari sur iPhone',
            email: testUser.email,
            status: 'active',
            reason: null,
            replacedBy: null,
            createdAt: Date.now(),
            revokedAt: null,
            lastUsed: Date.now(),
            tokenFamily: `device_${Date.now()}_2`
        };
        
        const sessionRef = firebaseAdmin.firestore().collection('sessions').doc();
        await sessionRef.set(sessionData);
        
        secondSession = {
            jti: sessionRef.id,
            ...sessionData
        };
        
        console.log('‚úÖ Deuxi√®me session cr√©√©e:', {
            jti: secondSession.jti,
            deviceLabel: secondSession.deviceLabel,
            status: secondSession.status
        });
        
        // Maintenant, r√©voquer la premi√®re session (simulation de la logique backend)
        await firebaseAdmin.firestore().collection('sessions').doc(testSession.jti).update({
            status: 'revoked',
            reason: 'replaced',
            replacedBy: secondSession.jti,
            revokedAt: Date.now()
        });
        
        console.log('‚úÖ Premi√®re session r√©voqu√©e automatiquement');
        
        return secondSession;
    } catch (error) {
        console.error('‚ùå Erreur cr√©ation deuxi√®me session:', error);
        throw error;
    }
}

/**
 * üß™ Test 4: Simulation de la d√©tection frontend
 */
async function simulateFrontendDetection() {
    console.log('\nüß™ Test 4: Simulation de la d√©tection frontend...');
    
    try {
        // Simuler l'√©coute Firestore temps r√©el
        console.log('üîç Configuration de l\'√©coute Firestore simul√©e...');
        
        // V√©rifier l'√©tat des sessions
        const firstSessionDoc = await firebaseAdmin.firestore()
            .collection('sessions')
            .doc(testSession.jti)
            .get();
        
        const secondSessionDoc = await firebaseAdmin.firestore()
            .collection('sessions')
            .doc(secondSession.jti)
            .get();
        
        const firstSessionData = firstSessionDoc.data();
        const secondSessionData = secondSessionDoc.data();
        
        console.log('üì± √âtat des sessions apr√®s r√©vocation:');
        console.log('   Session 1:', {
            jti: testSession.jti,
            status: firstSessionData.status,
            reason: firstSessionData.reason,
            replacedBy: firstSessionData.replacedBy,
            revokedAt: firstSessionData.revokedAt
        });
        
        console.log('   Session 2:', {
            jti: secondSession.jti,
            status: secondSessionData.status,
            reason: secondSessionData.reason
        });
        
        // Simuler la d√©tection de la r√©vocation
        if (firstSessionData.status === 'revoked') {
            console.log('üö® Session r√©voqu√©e d√©tect√©e en temps r√©el !');
            
            // Simuler l'√©mission de l'√©v√©nement frontend
            console.log('üì° √âmission de l\'√©v√©nement sessionRevoked...');
            
            // Simuler la gestion c√¥t√© frontend
            console.log('üîÑ Gestion automatique de la d√©connexion...');
            console.log('üì± Affichage de la modale Session R√©voqu√©e...');
            
            // Simuler les actions utilisateur
            console.log('üë§ Actions disponibles pour l\'utilisateur:');
            console.log('   - Se reconnecter');
            console.log('   - Signaler une activit√© suspecte');
            console.log('   - Fermer la modale');
        }
        
        return true;
    } catch (error) {
        console.error('‚ùå Erreur simulation frontend:', error);
        throw error;
    }
}

/**
 * üß™ Test 5: Validation des codes d'erreur
 */
async function validateErrorCodes() {
    console.log('\nüß™ Test 5: Validation des codes d\'erreur...');
    
    try {
        // Simuler une requ√™te avec une session r√©voqu√©e
        console.log('üîç Test de validation avec session r√©voqu√©e...');
        
        // R√©cup√©rer les informations de session
        const sessionInfo = await firebaseAdmin.firestore()
            .collection('sessions')
            .doc(testSession.jti)
            .get();
        
        const sessionData = sessionInfo.data();
        
        // Simuler la logique de validation c√¥t√© frontend
        if (sessionData.status === 'revoked') {
            const errorResponse = {
                success: false,
                code: 'SESSION_REVOKED',
                reason: sessionData.reason,
                replacedBy: sessionData.replacedBy,
                revokedAt: sessionData.revokedAt
            };
            
            console.log('‚úÖ Code d\'erreur normalis√© g√©n√©r√©:', errorResponse);
            
            // Simuler la gestion de l'erreur c√¥t√© frontend
            console.log('üîÑ Gestion de l\'erreur SESSION_REVOKED...');
            console.log('   - Arr√™t de l\'auto-refresh');
            console.log('   - D√©connexion automatique');
            console.log('   - Affichage de la modale');
        }
        
        return true;
    } catch (error) {
        console.error('‚ùå Erreur validation codes d\'erreur:', error);
        throw error;
    }
}

/**
 * üß™ Test 6: Nettoyage et validation finale
 */
async function cleanupAndValidation() {
    console.log('\nüß™ Test 6: Nettoyage et validation finale...');
    
    try {
        // V√©rifier que la premi√®re session est bien r√©voqu√©e
        const firstSessionDoc = await firebaseAdmin.firestore()
            .collection('sessions')
            .doc(testSession.jti)
            .get();
        
        const firstSessionData = firstSessionDoc.data();
        
        if (firstSessionData.status === 'revoked' && 
            firstSessionData.reason === 'replaced' && 
            firstSessionData.replacedBy === secondSession.jti) {
            
            console.log('‚úÖ Validation r√©ussie !');
            console.log('   - Session 1 r√©voqu√©e correctement');
            console.log('   - Raison: replaced');
            console.log('   - Remplac√©e par: Session 2');
            console.log('   - Aucune fen√™tre d\'acc√®s r√©siduel');
            
            return true;
        } else {
            console.error('‚ùå Validation √©chou√©e - √âtat de session incorrect');
            return false;
        }
    } catch (error) {
        console.error('‚ùå Erreur validation finale:', error);
        throw error;
    }
}

/**
 * üßπ Nettoyage des donn√©es de test
 */
async function cleanup() {
    console.log('\nüßπ Nettoyage des donn√©es de test...');
    
    try {
        // Supprimer les sessions de test
        if (testSession) {
            await firebaseAdmin.firestore()
                .collection('sessions')
                .doc(testSession.jti)
                .delete();
            console.log('üóëÔ∏è Session 1 supprim√©e');
        }
        
        if (secondSession) {
            await firebaseAdmin.firestore()
                .collection('sessions')
                .doc(secondSession.jti)
                .delete();
            console.log('üóëÔ∏è Session 2 supprim√©e');
        }
        
        // Supprimer l'utilisateur de test
        if (testUser) {
            await firebaseAdmin.firestore()
                .collection('users')
                .doc(testUser.uid)
                .delete();
            console.log('üóëÔ∏è Utilisateur de test supprim√©');
        }
        
        console.log('‚úÖ Nettoyage termin√©');
    } catch (error) {
        console.error('‚ùå Erreur lors du nettoyage:', error);
    }
}

/**
 * üöÄ Fonction principale de test
 */
async function runTests() {
    console.log('üöÄ D√©marrage des tests Frontend Sessions...');
    console.log('üì± Test de la gestion Single-Active-Session c√¥t√© frontend\n');
    
    try {
        // Ex√©cuter tous les tests
        await createTestUser();
        await createFirstSession();
        await createSecondSession();
        await simulateFrontendDetection();
        await validateErrorCodes();
        const validationResult = await cleanupAndValidation();
        
        // R√©sum√© des tests
        console.log('\nüéâ R√©sum√© des tests Frontend Sessions:');
        console.log('   ‚úÖ Cr√©ation utilisateur de test');
        console.log('   ‚úÖ Cr√©ation premi√®re session');
        console.log('   ‚úÖ Cr√©ation deuxi√®me session');
        console.log('   ‚úÖ Simulation d√©tection frontend');
        console.log('   ‚úÖ Validation codes d\'erreur');
        console.log(`   ${validationResult ? '‚úÖ' : '‚ùå'} Validation finale`);
        
        if (validationResult) {
            console.log('\nüéä Tous les tests Frontend Sessions sont PASS√âS !');
            console.log('üì± La gestion Single-Active-Session fonctionne correctement c√¥t√© frontend');
        } else {
            console.log('\n‚ùå Certains tests Frontend Sessions ont √âCHOU√â');
        }
        
    } catch (error) {
        console.error('\nüí• Erreur lors des tests:', error);
    } finally {
        // Nettoyer les donn√©es de test
        await cleanup();
        
        // Fermer la connexion Firebase
        await firebaseAdmin.app().delete();
        console.log('\nüîí Connexion Firebase ferm√©e');
    }
}

// Ex√©cuter les tests si le script est appel√© directement
if (require.main === module) {
    runTests().catch(console.error);
}

module.exports = {
    runTests,
    createTestUser,
    createFirstSession,
    createSecondSession,
    simulateFrontendDetection,
    validateErrorCodes,
    cleanupAndValidation,
    cleanup
};
